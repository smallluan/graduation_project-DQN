### v1_static版本指引:

#### 一、版本说明：
v1 版本指的是在根目录下mod后面以 `v1_static` 作为后缀的文件夹名称，对于不同版本的模型存在不同的`参数`，`训练方法`以及 `游戏规则`。

#### 二、游戏设计：

##### 1. 合法的动作：
在该版本中，双方各有**10张手牌**，最先清空手牌者胜利。合法的出牌动作包括 **单子**，**对子**， **三带一**。

#### 三、复杂度分析
##### 1. 计算各部分状态数量

**玩家和 AI 手牌状态数量**
我们可以使用生成函数的方法来计算玩家手牌（AI 手牌同理）的状态数量。考虑每种数字的牌有 \(0 - 4\) 张，我们可以用多项式 \((1 + x + x^{2}+x^{3}+x^{4})\) 来表示每种数字牌的选取情况。因为有 \(9\) 种数字的牌，所以表示手牌组合的生成函数为 \(G(x)=(1 + x + x^{2}+x^{3}+x^{4})^{9}\)。

我们需要找到 \(x^{10}\) 的系数，因为手牌总数是 \(10\) 张。可以使用 Python 的 `sympy` 库来计算：

```python
import sympy as sp

x = sp.Symbol('x')
G = (1 + x + x**2 + x**3 + x**4)**9
coeff = sp.expand(G).coeff(x, 10)
print(coeff)
```

运行这段代码可得玩家（或 AI）手牌的状态数量为 \(39279\) 种。

由于玩家和 AI 手牌状态相互独立，所以玩家和 AI 手牌的组合状态数量为 \(39279\times39279 = 1542849841\) 种。

**上一轮出牌状态数量**
- **单牌**：上一轮出的单牌可能是 \(1 - 9\) 中的任意一个数字，有 \(9\) 种可能状态。
- **对子**：对子的数字也可能是 \(1 - 9\) 中的任意一个，有 \(9\) 种可能状态。
- **三带一**：三带一的三个相同数字可以是 \(1 - 9\) 中的任意一个，而带的单牌可以是除了三个相同数字之外的 \(8\) 种数字之一，所以三带一的状态有 \(9\times8 = 72\) 种可能。
- **pass 状态**：表示上一轮没有出牌，这是一种额外的状态。

综合起来，上一轮出牌状态有 \(9 + 9+72 + 1 = 91\) 种可能。

**额外状态标记组合数量**
- **是否刚获得出牌权**：这是一个二值状态，即是或否，有 \(2\) 种可能。
- **上一轮是否出对子**：二值状态，\(2\) 种可能。
- **上一轮是否出三带一**：二值状态，\(2\) 种可能。
- **上一轮是否是 pass**：二值状态，\(2\) 种可能。

这些额外状态标记的组合状态数量为 \(2\times2\times2\times2 = 16\) 种。

##### 2. 计算总体状态复杂度
总体状态复杂度是上述各个因素的状态数量的乘积，即：

\(S = 1542849841\times91\times16\)
\(S=1542849841\times1456\)
\(S = 2246389368496\)


##### 复杂度总结
该纸牌游戏的状态复杂度非常高，总体状态数量达到了约 **\(2.25\times 10^{12}\) 种**。如此高的复杂度对游戏的训练和求解带来了巨大的挑战：
- **训练成本**：需要大量的训练数据来覆盖尽可能多的状态，以确保模型能够学习到有效的策略。这意味着训练时间会很长，并且需要强大的计算资源支持。
- **模型性能**：由于状态空间巨大，模型可能难以在所有状态下都达到最优表现，容易出现过拟合或泛化能力不足的问题。需要采用更复杂的模型结构和优化算法来提高模型的性能和泛化能力。
- **搜索空间**：在游戏过程中，搜索最优策略的空间也非常大，传统的搜索算法可能效率极低，需要使用更高效的搜索算法或启发式方法。 